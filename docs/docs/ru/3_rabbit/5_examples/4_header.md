# Header Exchange

**Header** Exchange - самый сложный и гибкий способ маршрутизации собщений в *RabbitMQ*. Данный тип `exchange` отправляет сообщения
в очереди в соответсвии с совпадением аргументов привязки этих очередей к `exchange` с заголовками сообщений.

При этом, если очередь слушает несколько потребителей, сообщения все также будут распределяться между ними.

## Пример

```python linenums="1"
{!> docs_src/rabbit/examples/header.py !}
```

### Объявление потребителей

Для начала мы объявили наш **Fanout** exchange и несколько очередей, которые будут его слушать:

```python linenums="8" hl_lines="1 5 9 13"
{!> docs_src/rabbit/examples/header.py [ln:8-21]!}
```

Аргумент `x-match` говорит о том, должны сопадать аргументы с заголовками сообщений полностью или частично.

Затем мы подписали несколько потребителей с помощью объявленных очередей на созданный нами `exchange`

```python linenums="23" hl_lines="1 5 9 13"
{!> docs_src/rabbit/examples/header.py [ln:23-37]!}
```

!!! note
    Обратите внимание, что `handler1` и `handler2` подписаны на один `exchange` с помощью одной и той же очереди:
    в рамках одного сервиса это не имеет смысла, так как сообщения будут приходить в эти обработчики поочередно.
    Здесь мы эмулируем работу несколько потребителей и балансировку нагрузки между ними.

### Распределение сообщений

Теперь распределение сообщений между этими потребителями будет выглядеть следующим образом:

```python
{!> docs_src/rabbit/examples/header.py [ln:43]!}
```

Сообщений `1` будет отправлено в `handler1`, т.к. он слушает очередь, заголовок `key` которой, совпал с заголовком `key` сообщения

---

```python
{!> docs_src/rabbit/examples/header.py [ln:44]!}
```

Сообщений `2` будет отправлено в `handler2`, т.к. он слушает `exchange` с помощью той же очереди, но `handler1` занят

---

```python
{!> docs_src/rabbit/examples/header.py [ln:45]!}
```

Сообщений `3` снова будет отправлено в `handler1`, т.к. он освободился на данный момент

---

```python
{!> docs_src/rabbit/examples/header.py [ln:46]!}
```

Сообщений `4` будет отправлено в `handler3`, т.к. он слушает очередь, заголовок `key` которой, совпал с заголовком `key` сообщения

---

```python
{!> docs_src/rabbit/examples/header.py [ln:47]!}
```

Сообщений `5` будет отправлено в `handler3`, т.к. он слушает очередь, заголовок `key2` которой, совпал с заголовком `key2` сообщения

---

```python
{!> docs_src/rabbit/examples/header.py [ln:48-49]!}
```

Сообщений `6` будет отправлено в `handler3` и `handler4`, т.к. заголовки сообщений полностью совпали с ключами очередей

---

!!! note
    При отправке сообщений в **Header** exchange нет смысл указывать аргументы `queue` или `routing_key`, т.к. они будут проигнорированы

!!! warning
    Для невероятно сложных маршрутов вы можете использовать возможность подписывать `exchange` на другой `exchange` с указанием ключа маршрутизации. В таком случае действуют все те же правила, что и для очередей, подписанных на `exchange`. Отличие только в том, что подписанный `exchange` может дальше распределять сообщения в соответствии со своими правилами.

    Так, например, вы можете совместить Topic и Header типы.