# Direct Exchange

**Direct** Exchange - базовый способ маршрутизации сообщений в *RabbitMQ*. Его суть очень проста:
`exchange` отправляет сообщения в те очереди, `routing_key` который совпадает с `routing_key` отправляемого сообщения.

!!! note
    **Default** Exchange, на который подписаны все очереди в *RabbitMQ* по умолчанию имеет тип **Direct**

## Масштабирование

Если одну очередь слушает несколько потребителей, сообщение будет уходить каждый раз новому потребителю. Это поведение общее для всех типов `exchange`, т.к. оно относится к самой очереди. Тип `exchange` влияет на то, в какие очереди попадет сообщение.

Таким образом, *RabbitMQ* может самостоятельно балансировать нагрузку на потребителей очереди. Вы можете увеличить скорость обработки потока
сообщений из очереди просто запустив дополнительные инстансы сервиса-потребителя. Вам не нужно вносить изменений в текущую конфигурацию инфраструктуры: *RabbitMQ* сам позаботится о том, как распределить сообщения между вашими сервисами.

## Пример

**Direct** Exchange - тип, используемый в **Propan** по умолчанию: вы можете просто объявить его следующим образом

```python
@broker.handler("test_queue", "test_exchange")
async def handler():
    ...
```

Аргумент `auto_delete=True` в этом и последующих примерах используется только для того, чтобы очистить состояние *RabbitMQ* после примера

```python linenums="1"
{!> docs_src/rabbit/direct.py !}
```

### Объявление потребителей

Для начала мы объявили наш **Direct** exchange и несколько очередей, которые будут его слушать:

```python linenums="8"
{!> docs_src/rabbit/direct.py [ln:8-11]!}
```

Затем мы подписали несколько потребителей с помощью объявленных очередей на созданный нами `exchange`

```python linenums="13" hl_lines="1 5 9"
{!> docs_src/rabbit/direct.py [ln:13-23]!}
```

!!! note
    Обратите внимание, что `handler1` и `handler2` подписаны на один `exchange` с помощью одной и той же очереди:
    в рамках одного сервиса это не имеет смысла, так как сообщения будут приходить в эти обработчики поочередно.
    Здесь мы эмулируем работу несколько потребителей и балансировку нагрузки между ними.

### Распределение сообщений

Теперь распределение сообщений между этими потребителями будет выглядеть следующим образом:

```python
{!> docs_src/rabbit/direct.py [ln:27]!}
```

Сообщение `1` будет отправлено в `handler1`, т.к. он слушает `exchange` с помощью очереди с ключом маршрутизации `test-q-1`

---

```python
{!> docs_src/rabbit/direct.py [ln:28]!}
```

Сообщение `2` будет отправлено в `handler2`, т.к. он слушает `exchange` с помощью той же очереди, но `handler1` занят

---

```python
{!> docs_src/rabbit/direct.py [ln:29]!}
```

Сообщение `3` снова будет отправлено в `handler1`, т.к. он освободился на данный момент

---

```python
{!> docs_src/rabbit/direct.py [ln:30]!}
```

Сообщение `4` будет отправлено в `handler3`, т.к. он единственный слушает `exchange` с помощью очереди с ключом маршрутизации `test-q-2`