# Pattern

**Pattern** Subject - мощный механизм маршрутизации *NATS*. Данный тип `subject` отправляет сообщения потребителям в соответсвии с *паттерном*,
указанном при их подключении к `subject` и ключом самого сообщения.

## Масштабирование

Если один `subject` слушает несколько потребителей с одинаковой `queue group`, сообщение будет уходить каждый раз случайному потребителю.

Таким образом, *NATS* может самостоятельно балансировать нагрузку на потребителей очереди. Вы можете увеличить скорость обработки потока сообщений из очереди просто запустив дополнительные инстансы сервиса-потребителя. Вам не нужно вносить изменений в текущую конфигурацию инфраструктуры: *NATS* сам позаботится о том, как распределить сообщения между вашими сервисами.

## Пример

```python linenums="1"
{!> docs_src/nats/pattern.py !}
```

### Объявление потребителей

Для начала мы объявили несколько потребителей для двух `subject`: `*.info` и `*.error`:

```python linenums="7" hl_lines="1 5 9"
{!> docs_src/nats/pattern.py [ln:7-17]!}
```

При этом в `subject` наших потребителей мы указываем *паттерн*, который будут обрабатываться этими потребителемя.

!!! note
    Обратите внимание, что все потребители подписаны с использованием одной `queue_group`: в рамках одного сервиса это не имеет смысла, так как сообщения будут приходить в эти обработчики поочередно.
    Здесь мы эмулируем работу несколько потребителей и балансировку нагрузки между ними.

### Распределение сообщений

Теперь распределение сообщений между этими потребителями будет выглядеть следующим образом:

```python
{!> docs_src/nats/pattern.py [ln:21]!}
```

Сообщение `1` будет отправлено в `handler1` или `handler2`, т.к. они слушают один шаблон `subject` в рамках одной `queue group`

---

```python
{!> docs_src/nats/pattern.py [ln:22]!}
```

Сообщение `2` будет отправлено аналогично сообщению `1`

---

```python
{!> docs_src/nats/pattern.py [ln:23]!}
```

Сообщение `3` будет отправлено в `handler3`, т.к. он единственный слушает шаблон `*.error*`