# LIFESPANS 

Иногда вам нужно определить логику, которая должна исполняться перед запуском приложения.
Это означает, что код будет исполнен один раз - еще до того, как ваше приложение начнет принимать сообщения.

Также, у вас может возникнуть необходимость завершить некоторые процессы после остановки приложения. В этом случае, ваш код также будет выполнен ровно один раз:
но уже после завершения работы основного приложения.

Поскольку этот код исполняется перед запуском приложения и после его остановки, он покрывает весь жизненный цикл *( lifespan )* приложения.

Это может быть очень полезно для инициализации настроек вашего приложения при старте, поднятия пула соединений к базе данных или запуска моделей машинного обучения.


## Пример использования

Давайте представим, что ваше приложение использует **pydantic** в качестве менеджера ваших настроек.

!!! note ""
    Я крайне рекомендую использовать **pydantic** для этих целей, т.к. эта зависимость уже используется в **Propan**
    и вам не придется устанавливать дополнительный пакет

Также, давайте представим, что у вас есть несколько `.env`, `.env.development`, `.env.test`, `.env.production` файлов с настройками вашего приложения,
и вы хотите переключать их при запуске без изменений в коде.

За счет [passing optional arguments with the command line](/Propan/2_getting_started/2_cli/#environment-management) в ваш код **Propan** позволяет вам с легкостью это сделать.

## Lifespan

Давайте напишем немного кода для нашего примера

=== "RabbitMQ"
    ```python linenums="1" hl_lines="12-16"
    {!> docs_src/quickstart/lifespan/1_rabbit.py!}
    ```

=== "NATS"
    ```python linenums="1" hl_lines="12-16"
    {!> docs_src/quickstart/lifespan/1_nats.py!}
    ```

Теперь это приложение можно запускать с помощью следующей команды для управления окружением:
```bash
$ propan run serve:app --env .env.test
```

### Детали

Теперь разберемся немного детальнее

Для начала, мы использовали декоратор 
```python linenums="12" hl_lines="1"
{!> docs_src/quickstart/lifespan/1_rabbit.py [ln:11-15] !}
```
для объявления функции, которая должна запускаться при старте нашего приложения

Следующим шагом мы объявили аргументы, которые будет получать наша функция
```python linenums="12" hl_lines="2"
{!> docs_src/quickstart/lifespan/1_rabbit.py [ln:11-15] !}
```
При этом поле `env` будет передано в функцию `setup` из аргументов командой строки
!!! tip
    Функции жизненного цикла по умолчанию используются с декоратором `@apply_types`,
    поэтому в них доступны все [поля контекста](/Propan/2_getting_started/5_dependency/2_context) и [зависимости](/Propan/2_getting_started/5_dependency/1_di-index)

Затем, мы инициализировали настройки нашего приложения с использованием переданного нам из командой строки файла
```python linenums="12" hl_lines="3"
{!> docs_src/quickstart/lifespan/1_rabbit.py [ln:11-15] !}
```

И поместили эти настройки в глобальный контекст
```python linenums="12" hl_lines="4"
{!> docs_src/quickstart/lifespan/1_rabbit.py [ln:11-15] !}
```

??? note
    Теперь мы можем получить доступ к нашим настройкам в любом месте приложения прямо из контекста

    ```python
    from propan import Context, apply_types
    @apply_types
    async def func(settings = Context()): ...
    ```

Последним шагом мы инициализировали нашего брокера: теперь, при старте приложения он будет готов принимать сообщения
=== "RabbitMQ"
    ```python linenums="12" hl_lines="5"
    {!> docs_src/quickstart/lifespan/1_rabbit.py [ln:11-15] !}
    ```

=== "NATS"
    ```python linenums="12" hl_lines="5"
    {!> docs_src/quickstart/lifespan/1_nats.py [ln:11-15] !}
    ```


## Другой пример

Теперь давайте представим, что у нас есть модель машинного обучения, которая должна обрабатывать сообщения из какого-либо брокера.

Обычна инициализация таких моделей занимает продолжительное время. Разумно будет сделать это при старте приложения, а не при обработке каждого сообщения.

Вы можете инициализировать вашу модель где-то вверху вашего модуля/файла. Однако, в таком случае, этот код будет запущен даже просто в случае импортирования
этого модуля, например, при тестировании. Вряд ли вы хотите запускать вашу модель на каждый запуск тестов...

Поэтому, стоит инициализированить модель в хуке `@app.on_startup`.

Также, мы не хотим, чтобы модель окончила свою работу при остановке приложения некорректно. Чтобы избежать этого, нам понадобиться хук `@app.on_shutdown`

=== "RabbitMQ"
    ```python linenums="1" hl_lines="12 18"
    {!> docs_src/quickstart/lifespan/2_ml_rabbit.py !}
    ```

=== "NATS"
    ```python linenums="1" hl_lines="12 18"
    {!> docs_src/quickstart/lifespan/2_ml_nats.py !}
    ```

## Несколько хуков

Если вы хотите объявить несколько хуков жизненного цикла, они будут использоваться в порядке их регистрации:

```python linenums="1" hl_lines="6 10"
{!> docs_src/quickstart/lifespan/3_multiple.py !}
```

## Еще немного деталей

### Async или не async
В асинхронной версии приложения в качестве хуков могут использоваться как асинхронные, так и синхронные методы.
В синхронной версии доступны только синхронные методы.

### Аргументы командной строки
Аргументы командной строки доступно во всех `@app.on_startup` хуках. Для использования их в других частях приложения
поместите их в `ContextRepo`.

### Инициализация брокера
Хуки `@app.on_startup` вызываются **ДО** запуска брокера приложением. Хуки `@app.on_shutdown` запускаются **ПОСЛЕ** остановки брокера.
