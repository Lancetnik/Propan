# Redis Publishing

Для отправки сообщений `RedisBroker` также использует унифицированный метод `publish`.

```python
import asyncio
from propan import RedisBroker

async def pub():
    async with RedisBroker() as broker:
        await broker.publish("Hi!", channel="test")

asyncio.run(pub())
```

## Базовые аргументы

Метод `publish` принимает следующие аргументы:

* `message`: bytes | str | dict | Sequence[Any] | pydatic.BaseModel - сообщение для отправки
* `channel`: str = "" - *channel*, куда будет отправлено сообщение.

## Параметры сообщения

*Redis* по умолчанию отправляет сообщение в виде сырых `bytes`. **Propan** же использует собственный формат передачи сообщения:
при вызове метода `publish` в *Redis* отправляется *json* со следующими полями:

```json
{
    "data": "",
    "headers": {},
    "reply_to": ""
}
```

Самостоятельно вы можете выставить и использовать в рамках своего приложения заголовки отправляемого сообщения (там же автоматически выставляется `content-type`, по которому **Propan** определяет, как декодировать полученное сообщение)

* `headers`: dict[str, Any] | None = None - заголовки отправляемого сообщения (используются потребителями)

!!! note ""
    Если **Propan** получает сообщение, отправленное с помощью другой библиотеки или фреймворка (или просто сообщение другого формата),
    все тело этого сообщение будет воспринято как поле `data` принимаемого сообщения, а `content-type` будет распознан автоматически.

    При этом **RPC** запросы не будут работать, так как во входящем сообщении нет поля `reply_to`.

## RPC аргументы

Также `publish` поддерживает общие аргументы для создания [*RPC* запросов](../../getting_started/4_broker/5_rpc/#_3):

* `reply_to`: str = "" - в какой *channel* отправить ответ (используется для асинхронных RPC запросов)
* `callback`: bool = False - ожидать ли ответ на сообщение
* `callback_timeout`: float | None = 30.0 - таймаут ожидания ответа. В случае `None` - ждет бесконечно
* `raise_timeout`: bool = False
    * `False` - возвращать None в случае таймаута
    * `True` - ошибка `TimeoutError` в случае таймаута
